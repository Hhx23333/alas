import os
import subprocess
from typing import Dict

from .requirements_updater import _requirements_modify

def parse_pip_compile_output(output: str):
    """
    Parse the output of a pip-compile run and return a dict of the requirements
    """
    requirements = {}
    for line in output.splitlines():
        if line.startswith('#'):
            continue
        try:
            pkg, version = line.strip().split("==")
            requirements[pkg] = version
        except ValueError:
            continue

    return requirements


def parse_requirements_in(input: str) -> dict:
    """
    Parse a requirements.in file and return a dict of the requirements
    """
    requirements = {}
    for line in input.splitlines():
        try:
            pkg, version = line.strip().split("==")
            requirements[pkg] = version
        except ValueError:
            requirements[line] = ""
    return requirements


def generate_requirements(reqs: dict) -> str:
    """
    Generate a requirements.txt file from a dict of requirements
    """
    output = []
    for pkg, version in reqs.items():
        if version:
            output.append(f"{pkg}=={version}")
        else:
            output.append(f"{pkg}")
    output.sort()
    return "\n".join(output)


def run_pip_compile(reqs: dict, exec: str, index_url: str):
    print("Run pip-compile with inputs:")
    print(reqs)
    with open("req-in.tmp", "w") as f:
        f.write(generate_requirements(reqs))

    args = []
    args.append(exec)
    args.append("--annotation-style=line")
    args.append("--resolver=backtracking")
    args.append(f"--index-url={index_url}")
    args.append("--no-emit-index-url")
    args.append("--no-annotate")
    args.append("--no-header")
    args.append("--output-file=req-out.tmp")
    args.append("req-in.tmp")
    args.append("-v")
    args.append("-U")

    subprocess.run(
        args,
        encoding="utf-8",
    )
    with open("req-out.tmp", "r") as f:
        output = f.read()

    try:
        os.remove("req-in.tmp")
        os.remove("req-out.tmp")
    except Exception:
        pass

    return parse_pip_compile_output(output)


header = """\
#
# This file is autogenerated by requirements_generator with Python 3.11
# by the following command:
#
#     python -m dev_tools.requirements_generator
#
"""


if __name__ == "__main__":
    #
    # Original pip-compile command
    # pip-compile --annotation-style=line --index-url=https://pypi.org/simple --no-emit-index-url --output-file=requirements.txt --resolver=backtracking --no-annotate --no-header requirements-in.txt
    # 
    # Install pip-compile with pip-tools
    # pip install pip-tools
    # You need pip>=22 and pip-tools>=6 to use this tool
    # Pip version in preinstalled Alas is 19.3.1, so you probably need to upgrade it or use your own python pip.
    #
    exec = "pip-compile"
    input_file = "requirements-in.txt"
    output_file = "requirements.txt"
    index_url = "https://pypi.org/simple"
    # Completely ignore the version of the dependency of these package
    ignore_dep_pkgs = {}
    # Keep these package but ignore the version in the final requirements.txt
    # ignore_resolve = {"opencv-python", "watchfiles"}
    ignore_resolve = {}

    with open(input_file, "r") as f:
        oin = parse_requirements_in(f.read())

    # Remove ignore packages
    for pkg in ignore_resolve:
        oin.pop(pkg, None)

    # Get ignore packages version
    ignores = {}
    for pkg in ignore_dep_pkgs:
        version = oin.pop(pkg, None)
        if version is None:
            continue
        ignores[pkg] = version

    # Get requirements for each ignore package
    ignores_deps: Dict[str, Dict[str, str]] = {}
    for pkg, version in ignores.items():
        reqs = run_pip_compile({pkg: version}, exec, index_url)
        ignores_deps[pkg] = reqs

    # Get requirements for other packages
    reqs = run_pip_compile(oin, exec, index_url)

    # Merge ignore packages dependencies
    extra_deps = {}
    for ipkg, ireqs in ignores_deps.items():
        for pkg, version in ireqs.items():
            if pkg in ignores:
                continue
            if pkg not in reqs:
                extra_deps[pkg] = ""

    reqs.update(extra_deps)

    if extra_deps:
        # Run pip-compile with extra dependencies again
        reqs = run_pip_compile(reqs, exec, index_url)

        # Add ignore packages back
        reqs.update(ignores)

    # Remove packages version that should to be resolved by pip
    for pkg in ignore_resolve:
        reqs[pkg] = ""

    # Generate requirements.txt
    with open(output_file, "w") as f:
        f.write(header)
        r = generate_requirements(reqs)
        r = _requirements_modify(r)
        f.write(r)
